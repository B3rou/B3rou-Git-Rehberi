# 1.3 - Git Ignore: GÃ¶rmezden Gelme SanatÄ±

Git, varsayÄ±lan olarak klasÃ¶rdeki her deÄŸiÅŸikliÄŸi sana rapor eder. Ancak bazÄ± dosyalar vardÄ±r ki, onlarÄ± ne repoda saklamak istersin ne de her `git status` yazdÄ±ÄŸÄ±nda o kalabalÄ±ÄŸÄ± gÃ¶rmek.

## 1. Neden BazÄ± DosyalarÄ± Gizleriz?

Her dosyayÄ± repoya atmak sadece yer kaplamaz, aynÄ± zamanda profesyonelliÄŸe aykÄ±rÄ±dÄ±r:
* **Gereksiz YÃ¼k:** Binlerce dosyalÄ±k kÃ¼tÃ¼phane klasÃ¶rleri (Ã–rn: `node_modules`, `vendor`).
* **Sistem DosyalarÄ±:** Ä°ÅŸletim sisteminin otomatik oluÅŸturduÄŸu kalÄ±ntÄ±lar (Ã–rn: `.DS_Store`, `Thumbs.db`).
* **DerlenmiÅŸ Dosyalar:** Kodun kendisi deÄŸil, Ã§Ä±ktÄ±sÄ± olan dosyalar (Ã–rn: `.exe`, `.o`, `.class`).
* **Ã–zel Veriler (âš ï¸ KRÄ°TÄ°K!):** API anahtarlarÄ±, ÅŸifreler veya kiÅŸisel ayarlarÄ±n olduÄŸu `.env` dosyalarÄ±. Bunlar Repoya/GitHub'a dÃ¼ÅŸerse projen ve gÃ¼venliÄŸin tehlikeye girer.

> **HatÄ±rla Git'in Distributed (DaÄŸÄ±tÄ±k) Felsefesi:** <br>
> *"'Git'te ise **herkes bir yedektir.'** Projeyi kendi bilgisayarÄ±na cloneladÄ±ÄŸÄ±n (indirdiÄŸin) an, projenin **1. gÃ¼nden bugÃ¼ne kadar olan tÃ¼m tarihÃ§esini, tÃ¼m versiyonlarÄ±nÄ± ve tÃ¼m veritabanÄ±nÄ±** indirirsin."*

---

## GÃ¶rev 1: Filtreyi OluÅŸturmak

Git'e "bunlara bakma" demek iÃ§in projenin ana dizinine `.gitignore` adÄ±nda Ã¶zel bir dosya oluÅŸturmamÄ±z gerekir.
> *Evet; dosyanÄ±n adÄ± yok, baÅŸÄ±nda nokta var ve bu bir uzantÄ±.*

Hadi test edelim:

1. Proje klasÃ¶rÃ¼nÃ¼n iÃ§inde `sirlar.txt` diye bir dosya oluÅŸtur ve iÃ§ine "Ã‡ok gizli ÅŸifrelerim" yaz.
2. Terminale `git status` yaz. Dosya **kÄ±rmÄ±zÄ±** gÃ¶rÃ¼necek (Untracked).

<img width="773" alt="git status output showing untracked sirlar.txt" src="https://github.com/user-attachments/assets/cf3ad1f7-d588-4b48-a9a7-02007d8eb91f" />
<br><br>

Åimdi Git'in gÃ¶zlerini baÄŸlayalÄ±m:

1. Projenin en dÄ±ÅŸ klasÃ¶rÃ¼nde (bu klasÃ¶re **root** denir) `.gitignore` adÄ±nda bir dosya oluÅŸtur.
2. Bu dosyanÄ±n iÃ§ine sadece ÅŸunu yaz ve kaydet:
```text
   sirlar.txt
```

> Burada Git'e *".gitignore'da yazan tÃ¼m dosyalarÄ±, root dizin dahil olmak Ã¼zere gÃ¶rmezden gel"* diyoruz.

3. Tekrar terminale `git status` yaz.

<img width="847" alt="git status output showing gitignore" src="https://github.com/user-attachments/assets/54d3c72d-ca9b-4cc7-8d27-93b6bcf51931" />






**BÃ¼yÃ¼!** âœ¨ `sirlar.txt` artÄ±k listede yok. Git artÄ±k o dosya orada olsa bile onu **gÃ¶rmezden geliyor.**

> Onun yerine `.gitignore`'u gÃ¶receksin. Git, `.gitignore`'u tanÄ±dÄ± ve istediÄŸin dosyalarÄ± dÄ±ÅŸladÄ±. LÃ¢kin henÃ¼z commitlenmediÄŸi iÃ§in `.gitignore` dosyasÄ±, henÃ¼z projenin hiÃ§bir commitinde (fotoÄŸrafÄ±nda) yok. Commitleyerek bu kurallar kitabÄ±nÄ± reponda kalÄ±cÄ±laÅŸtÄ±rabilirsin.

---

## YaygÄ±n KullanÄ±m KalÄ±plarÄ± (Syntax)

`.gitignore` dosyasÄ±nÄ±n kendine has bir dili vardÄ±r. Ä°ÅŸte en sÄ±k kullanacaÄŸÄ±n kalÄ±plar:

```gitignore
# 1. Belirli bir dosyayÄ± gizle
config.json

# 2. UzantÄ±ya gÃ¶re gizle (YÄ±ldÄ±z * = Her ÅŸey demektir)
*.log       # Sonu .log ile biten her ÅŸeyi gizle
*.tmp       # GeÃ§ici dosyalarÄ± gizle
*.exe       # DerlenmiÅŸ exe dosyalarÄ±nÄ± gizle

# 3. KlasÃ¶rleri gizle (Sonuna / koyulur)
node_modules/
temp/
build/

# 4. Ä°stisna Yapmak (Ãœnlem ! = Bunu gizleme)
# TÃ¼m .log dosyalarÄ±nÄ± gizle ama...
*.log
# ...important.log dosyasÄ±nÄ± hariÃ§ tut (gÃ¶ster)
!important.log

# 5. Dosya iÃ§erisinde kontrol
# DosyalarÄ±n hepsini gez ve eÅŸleÅŸenleri gizle
**/mycode.c

```

#### ğŸ” Close-Case Tablosu:

| Kural | AÃ§Ä±klama |
| --- | --- |
| `mycode.c` | Projenin **her yerindeki** `mycode.c` dosyalarÄ±nÄ± gizler. |
| `/mycode.c` | Sadece **root (kÃ¶k)** dizindeki `mycode.c` dosyasÄ±nÄ± gizler. |
| `**/mycode.c` | Herhangi bir alt klasÃ¶rdeki `mycode.c`'yi gizler (1. kural ile aynÄ±dÄ±r). |
| `debug/*.log` | `debug` klasÃ¶rÃ¼ndeki loglarÄ± gizler ama `debug/internal/test.log`'u **gizlemez**. |
| `debug/**/*.log` | `debug` klasÃ¶rÃ¼ ve onun **tÃ¼m alt klasÃ¶rlerindeki** loglarÄ± gizler. |

---

## Acil Durum: YanlÄ±ÅŸlÄ±kla Commit Ettim! (Cache TemizliÄŸi)

Bu, yazÄ±lÄ±mcÄ±larÄ±n en sÄ±k yaÅŸadÄ±ÄŸÄ± senaryodur:

1. Bir dosyayÄ± yanlÄ±ÅŸlÄ±kla `git add .` diyerek sahneye atarsÄ±n (hatta commitlersin).
2. Sonra "Eyvah, bu gizliydi!" diyip hemen `.gitignore` dosyasÄ±na eklersin.
3. Ama `git status` yapÄ±nca Git hala o dosyayÄ± takip eder!

**Neden?**
Ã‡Ã¼nkÃ¼ `.gitignore`, Git dÃ¼nyasÄ±nÄ±n **KapÄ± GÃ¼venliÄŸidir.** ğŸ‘®â€â™‚ï¸

* Dosyalar henÃ¼z kapÄ±dayken (Untracked) `.gitignore` onlarÄ± durdurabilir.
* Ancak bir dosya `git add` ile kapÄ±dan iÃ§eri girdiyse, Git artÄ±k ona **"Bizden Biri"** muamelesi yapar. Ä°Ã§erideki adam iÃ§in gÃ¼venlik kontrolÃ¼ yapÄ±lmaz.

Ä°ÅŸte `git rm --cached` komutu tam burada devreye girer. Bu komut Git'e ÅŸunu sÃ¶yler:

> *"Bu dosyayÄ± tanÄ±dÄ±ÄŸÄ±nÄ± unut ve onu kapÄ±nÄ±n Ã¶nÃ¼ne geri koy."*

BÃ¶ylece dosya tekrar iÃ§eri girmek istediÄŸinde, elindeki `.gitignore` listesine sahip gÃ¼venlik gÃ¶revlisi onu bu sefer tanÄ±yacak ve iÃ§eri almayacaktÄ±r.

**Ã‡Ã¶zÃ¼m:** 
DosyayÄ± **Git'in hafÄ±zasÄ±ndan (Index)** silmelisin ama **diskten (bilgisayarÄ±ndan)** silmemelisin.

Bunun iÃ§in ÅŸu komutu kullanÄ±rÄ±z:

```bash
git rm --cached sirlar.txt

```

* `git rm`: Sil.
* `--cached <dosya-yolu>`: Sadece Index'ten (Git'in sahnesinden) sil, **dosyama dokunma.**

> [!CAUTION]
> **DÄ°KKAT!**
> Bu kÄ±sÄ±m kritiktir. `--cached` argÃ¼manÄ±, Git'in takibinden (track) silmeyi temsil eder. KoyulmadÄ±ÄŸÄ± takdirde Git; tracki deÄŸil, **dosyanÄ± bilgisayarÄ±ndan silecektir!**

Bu komutu yazdÄ±ktan sonra commit atarsan, dosya repodan silinir ama senin bilgisayarÄ±nda (Working Directory) gÃ¼vende kalÄ±r.

> [!WARNING]
> **Git Unutmaz!**
> Git; *"Depolama, emekten Ã¶nemsizdir"* felsefesini taÅŸÄ±r. Bu yÃ¼zden silindiÄŸini sandÄ±ÄŸÄ±n Ã§oÄŸu ÅŸey, aslÄ±nda revert edilebilir. <br>
> EÄŸer API keyini veya Ã¶zel bir bilgini yanlÄ±ÅŸlÄ±kla commit ettiysen endiÅŸelenme ama dikkatli ol, Ã§Ã¼nkÃ¼ bu kodlar ve keyler geÃ§miÅŸten (history) geri getirilebilir! (Bunu ileride temizlemeyi Ã¶ÄŸreneceÄŸiz).

---

## âœ… Kontrol NoktasÄ±

1. `.gitignore` dosyasÄ±nÄ± oluÅŸturdun mu? (AdÄ± tam olarak bu olmalÄ±).
2. Gizlemek istediÄŸin dosya yollarÄ±nÄ± doÄŸru yazdÄ±n mÄ±?
3. EÄŸer dosya inatla gitmiyorsa `git rm --cached` komutunu denedin mi?

---

## Ã–zet ve Yeni Yetenekler

Bu derste sadece commit atmayÄ± deÄŸil, **Repo Hijyeni** saÄŸlamayÄ± Ã¶ÄŸrendin. Yeni Ã¶ÄŸrendiÄŸin komutlar sayesinde temel dÃ¼zenlemelerin bazÄ±larÄ±nÄ± yapabileceksin.

> [!TIP]
> **Yeni Yetenek Kilidi AÃ§Ä±ldÄ±: `.gitignore`**
> * Git'in takip etmesini istemediÄŸin dosya ve klasÃ¶rleri tanÄ±mladÄ±ÄŸÄ±n metin dosyasÄ±dÄ±r.
> * BulunduÄŸu dosyadan baÅŸlayarak iÃ§erisindeki tÃ¼m dosyalara etki eder. HiyerarÅŸiktir.
> * Yani `/.gitignore` dosyasÄ± tÃ¼m projeyi kapsarken `/docs/.gitignore`, docs'u ve iÃ§erisindeki tÃ¼m directoryleri kapsar.
> * Genelde root directorye koyulur, Ã§Ã¼nkÃ¼ tÃ¼m projede bu kurallarÄ±n geÃ§erli olmasÄ± beklenir.
> * Bir projede birden fazla `.gitignore` dosyasÄ± kullanÄ±labilir. <br><br>
> Daha da fazla detay iÃ§in [.gitignore resmi aÃ§Ä±klamasÄ±na](https://git-scm.com/docs/gitignore) bakabilirsin.

> [!TIP]
> **Yeni Yetenek Kilidi AÃ§Ä±ldÄ±: `git rm --cached`**
> * **Hayat KurtarÄ±cÄ±:** DosyayÄ± fiziksel olarak silmeden, sadece Git'in takibinden (Staging Area) Ã§Ä±karÄ±r. `.gitignore`'un Ã§alÄ±ÅŸmadÄ±ÄŸÄ± durumlarda ilk baÅŸvurulacak ilaÃ§tÄ±r.

> [!NOTE]
> **Tam Temizlik: `git rm -r --cached .`**
> * Bu komutu kullanarak Git'in **tÃ¼m tracklerini (takip listesini)** silebilirsin. Merak etme, `--cached` argÃ¼manÄ± dosyalarÄ±nÄ± korur.
> * `-r` argÃ¼manÄ±, **recursive (yinelemeli)** demektir. Buradaki amacÄ± tÃ¼m trackleri silene kadar iÅŸlemi alt klasÃ¶rlerde tekrar etmektir.
> * Bu komutun kullanÄ±lma amacÄ±; var olan trackler Ã§ok karÄ±ÅŸÄ±rsa ya da herkesi tekrar `.gitignore` sÃ¼zgecinden geÃ§irmek istersen kullanÄ±lÄ±r.
> * ArdÄ±ndan daha Ã¶nce Ã¶ÄŸrendiÄŸin `git add .` ile dosyalarÄ±nÄ± tertemiz bir ÅŸekilde tekrar trackleyebilirsin.

---

# ğŸ‰ BÃ¶lÃ¼m Sonu: Genesis TamamlandÄ±

Tebrikler! Git Ã¶ÄŸrenme yolculuÄŸunun ilk ve en Ã¶nemli adÄ±mÄ± olan **Genesis (YaratÄ±lÄ±ÅŸ)** modÃ¼lÃ¼nÃ¼ baÅŸarÄ±yla tamamladÄ±n. ArtÄ±k sadece kod yazan birisi deÄŸil, **"neden?"** sorusunu soran ve cevaplarÄ±nÄ± arayan bir geliÅŸtiricisin.

### ğŸ† Neler BaÅŸardÄ±n?
Bu modÃ¼lde ÅŸunlarÄ± heybene koydun:
- [x] **Kurulum:** Git'i bilgisayarÄ±na kurdun ve hangi konfigÃ¼rasyonlarÄ±n kritik olduÄŸunu tanÄ±dÄ±n.
- [x] **Teori:** Git'in dosya farklarÄ±nÄ± deÄŸil, anlÄ±k gÃ¶rÃ¼ntÃ¼leri (Snapshot) sakladÄ±ÄŸÄ±nÄ± anladÄ±n. AyrÄ±ca git'in dÃ¼ÅŸÃ¼nce yapÄ±sÄ±nÄ± inceledin.
- [x] **YaratÄ±lÄ±ÅŸ:** `git init` ile sÄ±radan bir klasÃ¶re ruh Ã¼fledin.
- [x] **KayÄ±t:** `add` ve `commit` ile tarihe silinmez notlar dÃ¼ÅŸtÃ¼n.
- [x] **Hijyen:** `.gitignore` ile gereksiz veya kritik dosyalarÄ± kapÄ±dan Ã§evirmeyi Ã¶ÄŸrendin.

---

## ğŸš€ SÄ±rada Ne Var?

Åu ana kadar gÃ¼venli bir limandaydÄ±k. Tek bir zaman Ã§izgisinde (main), tek baÅŸÄ±mÄ±za ilerledik.

Ama Git'in gerÃ§ek gÃ¼cÃ¼ **"Paralel Evrenler"** yaratabilmesidir.
Bir sonraki bÃ¶lÃ¼mde, Ã§alÄ±ÅŸan kodunu bozmadan nasÄ±l Ã§Ä±lgÄ±n deneyler yapabileceÄŸini, aynÄ± anda birden fazla Ã¶zellikle nasÄ±l uÄŸraÅŸabileceÄŸini ve ekibinle birbirinizi bozmadan geliÅŸtirme yapabileceÄŸini Ã¶ÄŸreneceksin.

> [!IMPORTANT]
> Ama Ã¶ncelikle kendini bir tebrik et! Ä°nsanlar git'in genelde yalnÄ±zca `add` `commit` `push` komutlarÄ±nÄ± bilirken sen `add` ve `commit`'in detaylarÄ±nÄ± Ã¶ÄŸrendin ve gÃ¼mbÃ¼r gÃ¼mbÃ¼r geliyorsun! Bu motivasyonunu kaybetme! ğŸ’œ

HazÄ±rsan, evreni bÃ¶lmeye gidiyoruz.

ğŸ‘‰ **BÃ¶lÃ¼m 2, Multiverse'e BaÅŸla:** [2.0 - Multiverse: Branch Anatomisi](../2-multiverse/2.0-branch-mantigi.md) <br>

ğŸ‘‰ **Bu BÃ¶lÃ¼mde Yetenek AÄŸacÄ±na Neler Ekledin:** [1.4 - Yetenek AÄŸacÄ±m: BÃ¶lÃ¼m Ã–zeti](./1.4-bolum-ozeti.md) <br>

ğŸ‘‰ **Biraz Soluklanmak Ä°stersen :** [0.0 - Ana Sayfaya DÃ¶n: Root README](../../README.md)