# 2.0 - Multiverse: Branch Anatomisi ğŸŒŒ

> *"Main branch Ã¼zerinde Ã§alÄ±ÅŸmak, pimi Ã§ekilmiÅŸ el bombasÄ±yla oynamak gibidir. Branch aÃ§mak ise o bombayÄ± gÃ¼venli bir test odasÄ±na kilitlemektir."*

Åu ana kadar **Genesis** modÃ¼lÃ¼nde "tek ÅŸeritli bir yolda" (main) ilerledik. Bu kulaÄŸa basit gelse de aslÄ±nda **tehlikeliydi**. Ã‡Ã¼nkÃ¼ o tek Ã§izgide yapacaÄŸÄ±n hatalÄ± bir commit, projenin Ã§alÄ±ÅŸan halini bozabilirdi.

GerÃ§ek bir mÃ¼hendis; Ã§alÄ±ÅŸan kodu (Production) riske atmadan **Ã§Ä±lgÄ±n deneyler** yapmak, yeni Ã¶zellikler eklemek veya bir hatayÄ± (bug) dÃ¼zeltmek istediÄŸinde kendine **"Ä°zole Bir Evren"** yaratÄ±r. Ä°ÅŸte Git'te buna **Branching (Dallanma)** diyoruz.

AsÄ±l gÃ¼venli liman burasÄ±dÄ±r; Ã§Ã¼nkÃ¼ burada yaptÄ±ÄŸÄ±n hiÃ§bir ÅŸey ana projeyi sen istemedikÃ§e etkilemez! Yani sen Ã¶zgÃ¼rce Ã¼zerinde oynama yapabilir, commit atabilir ve kayÄ±t almaya devam edebilirsin. DilediÄŸin vakitte ise bu eklemelerini ana Ã§izgiye ekleyebilir, ya da hoÅŸuna gitmezse bu dalÄ± (branch) kesip atabilirsin. BÃ¶ylece projene hiÃ§bir ÅŸey olmamÄ±ÅŸ gibi devam edebilirsin.

---


> [!IMPORTANT]
> ### HazÄ±rlÄ±k: LaboratuvarÄ± Kurma
> 
> Bu derste anlatÄ±lanlarÄ± uygulayabilmen iÃ§in bir Git reposu Ã¼zerinde olman gerekiyor. EÄŸer Ã¶nceki bÃ¶lÃ¼mlerden kalan `Git-Egitimi` klasÃ¶rÃ¼n duruyorsa oradan devam et. <br><br> **EÄŸer yoksa veya temiz bir sayfa aÃ§mak istiyorsan aÅŸaÄŸÄ±daki seÃ§eneklerden birini seÃ§:**

<details>
<summary> <b>Laboratuvar OrtamÄ±nÄ± Kurmak Ä°Ã§in TÄ±kla</b> (3 FarklÄ± Yol)</summary>

#### Yol 1: Temiz BaÅŸlangÄ±Ã§ (Ã–nerilen) âœ¨
SÄ±fÄ±rdan, tertemiz bir klasÃ¶r ve repo oluÅŸturur. Kafan karÄ±ÅŸmaz.
```bash
cd Desktop                                 # MasaÃ¼stÃ¼ne gel.
mkdir Branch-Deneyi                        # KlasÃ¶r oluÅŸtur.
cd Branch-Deneyi                           # Ä°Ã§ine gir.
git init                                   # KlasÃ¶rÃ¼ Repo'ya dÃ¶nÃ¼ÅŸtÃ¼r.
echo "Ana Evren" > evren.txt               # Terminal aracÄ±lÄ±ÄŸÄ±yla iÃ§inde "Ana Evren" yazan bir .txt oluÅŸtur.
git add .                                  # Stage et.
git commit -m "feat: initial release"      # Commitle.
```

#### Yol 2: Bu Repoyu da Kullanabilirsin

Åu an okuduÄŸun **B3rou-Git-Rehberi** projesini bilgisayarÄ±na indirip, bu dokÃ¼manlar Ã¼zerinde deney yapabilirsin. AÃ§Ä±k kaynaÄŸÄ±n gÃ¼zelliÄŸi budur!

```bash
git clone https://github.com/B3rou/B3rou-Git-Rehberi.git
cd B3rou-Git-Rehberi
```

#### Yol 3: AÃ§Ä±k KaynaÄŸÄ±n EtkileyiciliÄŸine Ä°lk Elden TanÄ±k Olabilirsin:

> Biraz deneyimin yoksa bu yÃ¶ntemi pas geÃ§. 

GitHub'daki popÃ¼ler projeleri indirip onlarÄ±n branch yapÄ±larÄ±nÄ± inceleyebilirsin (Ama Ã¼zerinde deÄŸiÅŸiklik yaparken dikkatli ol).

```bash
# Ã–rnek: React projesini indir
git clone <popÃ¼ler bir reponun remote URL'sini bul>
cd <dosya-adi>
```

---

**HazÄ±r mÄ±sÄ±n?** Terminalinde `(main)` veya `(master)` yazÄ±sÄ±nÄ± gÃ¶rÃ¼yorsan deney baÅŸlasÄ±n.

> `git status` ya da `git branch` yazarak teyit edebilirsin.

</details>

---

## 1. Branch AslÄ±nda Nedir?

Ã‡oÄŸu kiÅŸi branch aÃ§tÄ±ÄŸÄ±nda Git'in arka planda dosyalarÄ± kopyalayÄ±p yeni bir klasÃ¶r oluÅŸturduÄŸunu sanÄ±r. **Bu tamamen yanlÄ±ÅŸtÄ±r.** EÄŸer Ã¶yle olsaydÄ±, 10 GB'lÄ±k bir projede her branch aÃ§tÄ±ÄŸÄ±nda diskin dolardÄ±.

Git Ã§ok daha zekidir:

1. **Commitler:** YaptÄ±ÄŸÄ±n gÃ¼ncellemeleri tutan, varsa parentini (bir Ã¶nceki commiti) hatÄ±rlayan sÃ¼rÃ¼mlerdir. (snapshotlardÄ±r)
2. **Branchler:** Sadece ve sadece **dallanmanÄ±n (branch) son Commit'inin HASH'Ä±nÄ± tutan** Genelde 41 byteâ€™lÄ±k Ã§ok kÃ¼Ã§Ã¼k bir referans dosyasÄ±dÄ±r.

> Referans dosyasÄ±: Bir ÅŸeyin nerede olduÄŸunu gÃ¶steren dosya.

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://github.com/user-attachments/assets/dd4bc51c-2bda-435b-8783-f607d38847a9">

  <source media="(prefers-color-scheme: light)" srcset="https://github.com/user-attachments/assets/9b6b0232-2f61-462e-bc58-6fa2fcd4e66e">

  <img alt="Git Branch Veri YapÄ±sÄ± ve Linked List MantÄ±ÄŸÄ±" src="https://github.com/user-attachments/assets/9b6b0232-2f61-462e-bc58-6fa2fcd4e66e">
</picture>


Yani Branch, bir **Pointer (Ä°ÅŸaretÃ§i)**'dir. KullanÄ±m amacÄ± gereÄŸi kastedilen birden Ã§ok commit olsa da branch, atomik boyutta yalnÄ±zca 1 commiti iÅŸaret eden dosyadan ibarettir.

### HEAD: "Sen BuradasÄ±n" ğŸ“

Terminalde sÄ±k sÄ±k gÃ¶rdÃ¼ÄŸÃ¼n o `HEAD` yazÄ±sÄ±, aslÄ±nda Git'in sana *"Åu an bu branch'e bakÄ±yorsun"* deme ÅŸeklidir.

* **Senaryo:** `main` branchtayÄ±z.
* `HEAD` â¡ï¸ `main` â¡ï¸ `Commit A`


* **Senaryo:** `yeni-ozellik` branchÄ±na geÃ§tik.
* `HEAD` â¡ï¸ `yeni-ozellik` â¡ï¸ `Commit A`

> [!IMPORTANT]
> AslÄ±nda HEAD, baktÄ±ÄŸÄ±n commiti gÃ¶steren bir pointerdÄ±r.
> * EÄŸer HEAD, bir branch dosyasÄ± aracÄ±lÄ±ÄŸÄ±yla commite bakÄ±yorsa buna Attached HEAD state denir. Commit attÄ±kÃ§a HEAD da Branch de sonraki commit'e kayar.
> * EÄŸer bir branch aracÄ±lÄ±ÄŸÄ±yla ile HEAD'Ä± yerleÅŸtirmek yerine doÄŸrudan gidip commite HASH ile yer deÄŸiÅŸtirirsen, bu duruma Detached HEAD state denir. Bu durum tehlike arz eder.

> [!CAUTION]
> Detached State'deyken Git sana "Åu an hiÃ§bir dala tutunmuyorsun, boÅŸluktasÄ±n" der. Bu statedeyken atÄ±lan commitler'e dangling (sarkÄ±k) commitler denir. YalnÄ±zca ne yaptÄ±ÄŸÄ±nÄ± bilen insanlarÄ±n manuel dangling commitler atmasÄ± gerekir.

> [!TIP]
> Dangling commitler hem Ã§ok iÅŸlevsel, hem de Ã§ok tehlikelidir. Bu commitler yalnÄ±zca manuel atÄ±lmaz, ayrÄ±ca `amend` ve `reset` gibi geri alma ve deÄŸiÅŸtirme iÅŸlemlerinde branch ve HEAD'Ä±n yeri deÄŸiÅŸir, ancak o eski commit orada sarkÄ±k bir ÅŸekilde varlÄ±ÄŸÄ±nÄ± sÃ¼rdÃ¼rÃ¼r. Ta ki git garbage collector gelip onu aÄŸacÄ±ndan kazÄ±yÄ±p alana kadar. EÄŸer sildiÄŸin commiti nasÄ±l geri getireceÄŸini merak ediyorsan, bu sistem bu iÅŸin kalbidir.

<details>
<summary> Bir Dangling Commit BÃ¶yle GÃ¶rÃ¼nÃ¼r: </summary>
  
<br>
  
AÅŸaÄŸÄ±da gÃ¶receÄŸin grafiÄŸi henÃ¼z okuyamÄ±yor olabilirsin, sakin ol ve Ã¶ncelikle bir gÃ¶z gezdir:
  
<img width="867" height="440" alt="Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ 2026-01-28 233908" src="https://github.com/user-attachments/assets/c4ea154d-7fa0-45ca-af33-188d9f81f855" />

Bu grafik ÅŸunu sÃ¶yler, ana dalda bir yerde `oops: that is an unintended, reseted commit` adlÄ±nda, merge edilmemiÅŸ veya sonunu gÃ¶steren bir branch olmayan, **DANGLING COMMIT** var.

Dikkatli incelersen dallanmanÄ±n ana dalla asla birleÅŸmediÄŸini, ya da bir branch ile gÃ¶sterilmediÄŸini farkedeceksin. Ek olarak main branchÄ±n sonundaki "HEAD -> main, paralel-evren" ibaresi, HEAD'Ä±n orada olduÄŸunu ve main'i gÃ¶sterdiÄŸini, aynÄ± noktada ayrÄ±ca "paralel-evren" adÄ±nÄ± taÅŸÄ±yan bir branch olduÄŸunu gÃ¶sterir.

</details>

---

## 2. Eski vs Modern: `checkout` ve `switch`

Ä°nternetteki eski kaynaklarda dal deÄŸiÅŸtirmek iÃ§in `git checkout` komutunu gÃ¶rebilirsin. Ancak `checkout` komutu Git'in "Ä°sviÃ§re Ã‡akÄ±sÄ±" gibidir; hem zamanda yolculuk yapar, hem dosyalarda Ã¶nemli oynamalar yapar, hem dal deÄŸiÅŸtirir. Bu da kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ±na yol aÃ§ar.

Git geliÅŸtiricileri 2019'da (v2.23), checkout komutunu 2'ye ayÄ±rdÄ±lar. AmaÃ§larÄ± ise basitti: kafa karÄ±ÅŸÄ±klÄ±klarÄ±nÄ± Ã¶nlemek, yapÄ±lan hatalarÄ±n Ã¶nÃ¼ne geÃ§mek ve Ã¶ÄŸrenim kolaylÄ±ÄŸÄ±nÄ± arttÄ±rmak. 

Bu elmanÄ±n 2 yarÄ±sÄ±ndan Ã¶ÄŸreneceÄŸin ilk komut `git switch` olacak:

| Ä°ÅŸlem | Modern Komut (Ã–nerilen âœ¨) | Eski Komut |
| --- | --- | --- |
| **Dal DeÄŸiÅŸtirmek** | **`git switch <isim>`** | `git checkout <isim>` |
| **Yeni Dal Yaratarak DeÄŸiÅŸtirmek** | **`git switch -c <isim>`** | `git checkout -b <isim>` |

> Git, sadece zor kullanÄ±m sunduÄŸu iÃ§in eski komutlarÄ±nÄ± kullanÄ±mdan Ã§Ä±kartmaz. Bu, kullanÄ±cÄ±larÄ±na bÃ¼yÃ¼k bir saygÄ±sÄ±zlÄ±k olur.
>
> Checkout Ã¶zelliÄŸi hala vardÄ±r ve Ã§ok sÄ±k kullanÄ±lÄ±r. GeliÅŸtiricilerin Ã§oÄŸu hala eski usÃ¼l `git checkout` kullanÄ±r. EÄŸitimin de Ã§ok yÃ¶nlÃ¼lÃ¼k ve herkese yÃ¶nelik olma ilkeleri altÄ±nda bu komutu da tanÄ±tÄ±yorum.
> Ezberlemene gerek yok, keza switch ile syntaxÄ± ve mantÄ±ÄŸÄ± neredeyse aynÄ±. `switch` komutunun, `checkout`'un bÃ¶lÃ¼nmesinin Ã¼rÃ¼nÃ¼ olduÄŸunu unutmayalÄ±m.

---

## Uygulama: "GÃ¶rÃ¼nmezlik" Deneyi

Teori bitti. Åimdi terminalini aÃ§ ve sihrin gerÃ§ekleÅŸtiÄŸini kendi gÃ¶zlerinle gÃ¶r.

### AdÄ±m 0: Varolan BranchlarÄ± Kontrol Et

BulunduÄŸun repodaki branchlarÄ± Ã¶ÄŸrenerek baÅŸlayalÄ±m.

```bash
git branch
```

Ã–nÃ¼ne gelen liste, repodaki tÃ¼m branchlarÄ± sana gÃ¶sterecektir. BaÅŸÄ±nda `*` simgesini iÃ§eren branch, HEAD'Ä±n attached olduÄŸu branch'i simgeler. Bu branch genelde yeÅŸil gÃ¶sterilir.

EÄŸer yalnÄ±zca `*main` yazÄ±yorsa Ã¼zÃ¼lme! Ã‡Ã¼nkÃ¼ ÅŸimdi kendi evrenimizi yaratacaÄŸÄ±z:

### AdÄ±m 1: Yeni Bir Evren Yarat

HenÃ¼z bir yere gitmiyoruz, sadece evrenin adÄ±nÄ± koyuyoruz.

```bash
git branch paralel-evren
```

*(Bu komut Ã§Ä±ktÄ± vermez. Sadece etiketi yarattÄ±. `git branch` ile kontrol edebilirsin)*

### AdÄ±m 2: Evrene GeÃ§iÅŸ Yap

Åimdi `HEAD` iÅŸaretÃ§isini yeni dala taÅŸÄ±yalÄ±m.

```bash
git switch paralel-evren
```
ya da eski yÃ¶ntem ile:
```bash
git checkout paralel-evren
```

> **Terminal:** *"Switched to branch 'paralel-evren'"*

### AdÄ±m 3: KanÄ±t (Magic Trick ğŸ©)

Bu adÄ±mda branchlerin gerÃ§ekten izole olduÄŸunu kanÄ±tlayacaÄŸÄ±z.

1. **Dosya Yarat:** Bu daldayken `gizli-dosya.txt` adÄ±nda bir dosya oluÅŸtur ve iÃ§ine "BurasÄ± paralel evren" yaz.
2. **Commit At:** (BurasÄ± Ã§ok Ã¶nemli, commit atmazsan dosya dalÄ±n parÃ§asÄ± olmaz).
```bash
git add .
git commit -m "feat: add secret note"
```

3. **Ana Evrene DÃ¶n:** Åimdi `main` dalÄ±na geri dÃ¶nelim.
```bash
git switch main
```

4. **BÃ¼yÃ¼ye Bak:** KlasÃ¶rÃ¼ne bak (veya `ls` yaz). `gizli-dosya.txt` **YOK OLDU!**
* Korkma, silinmedi. Sadece o dosya diÄŸer evrende (zamanda) kaldÄ±.

5. **Geri DÃ¶n:**
```bash
git switch paralel-evren
```

* DosyanÄ±n geri geldiÄŸini gÃ¶receksin.

Ä°ÅŸte Git'in gÃ¼cÃ¼ budur. Ana projen (Main) tertemiz dururken, yan dallarda masayÄ± istediÄŸin kadar daÄŸÄ±tabilir, bozabilir ve deney yapabilirsin.

---

## MÃ¼hendis GÃ¶zÃ¼yle: Kaputun AltÄ±

Sana "Branch sadece bir dosyadÄ±r" demiÅŸtim. Ä°nanmÄ±yorsan gel bakalÄ±m.

Terminalde ÅŸu komutu yaz (veya `.git/refs/heads/` klasÃ¶rÃ¼ne git):

```bash
# Windows (PowerShell)
Get-Content .git/refs/heads/main

# Mac/Linux
cat .git/refs/heads/main
```

KarÅŸÄ±na Ã§Ä±kan o garip sayÄ± ve harfler (`a1b2c3...`), o dalÄ±n iÅŸaret ettiÄŸi son commit'in kimliÄŸidir. Branch dediÄŸimiz ÅŸey, teknik olarak sadece bu metin dosyasÄ±ndan ibarettir.

---

## Yeni Yeteneklerin!
> ve sÄ±kÄ±cÄ± bir komut listesi...

| Komut | AÃ§Ä±klama |
| --- | --- |
| `git branch` | Mevcut dallarÄ± listeler. YÄ±ldÄ±z (*) olan, ÅŸu an bulunduÄŸun daldÄ±r. |
| `git branch <isim>` | Yeni bir dal oluÅŸturur. |
| `git switch <isim>` | O dala geÃ§iÅŸ yapar. |
| `git switch -c <isim>` | Yeni dal oluÅŸturur ve **anÄ±nda** oraya geÃ§er (`create` kÄ±saltmasÄ±). |
| `git branch -d <isim>` | DalÄ± siler (`delete` kÄ±saltmasÄ±). |
| `git branch -M <isim>` | BulunduÄŸun dalÄ±n adÄ±nÄ± deÄŸiÅŸtirir. |
| `git checkout <isim>` | (Eski YÃ¶ntem) O dala geÃ§iÅŸ yapar. |
| `git checkout -b <isim>` | (Eski YÃ¶ntem) Yeni dal oluÅŸturur ve anÄ±nda oraya geÃ§er. |

> [!TIP]
> Git, sÃ¼rekli ince eleyip sÄ±k dokur ve veri gÃ¼venliÄŸine Ã¶nem verir. Bazen bazÄ± komutlar, dosyalarÄ± kalÄ±cÄ± olarak ezebilir ya da silebilir ve git, seni durduracaktÄ±r. EÄŸer ne yaptÄ±ÄŸÄ±nÄ± biliyorsan ve bu engelin Ã¶nÃ¼ne geÃ§mek istiyorsan her zaman `--force` ya da `-f` yazarak geÃ§iÅŸ izni alabilirsin. Yine de kullanÄ±rken dikkat et, benden sÃ¶ylemesi! 

> [!TIP]
> `git switch -` ile son dalÄ±na geri dÃ¶nebilirsin. Bu bazen iÅŸleri hÄ±zlandÄ±rÄ±r!
> * Bu kÄ±sayol aslÄ±nda Linux/Unix Shelldeki `cd -` komutundan miras alÄ±nmÄ±ÅŸtÄ±r. NasÄ±l ki terminalde `cd -` yazÄ±nca "son bulunduÄŸum klasÃ¶re geri dÃ¶n" diyorsan, Git'te de aynÄ± mantÄ±k iÅŸler.
> * Git arka planda bunu @{-1} olarak algÄ±lar (yani: HEAD'in bir Ã¶nceki konumu).

---

ğŸ‰ **Tebrikler!** ArtÄ±k tek bir Ã§izgide yÃ¼rÃ¼mek zorunda deÄŸilsin. Evreni bÃ¶ldÃ¼n.
Peki bu bÃ¶ldÃ¼ÄŸÃ¼mÃ¼z evrenleri (dallarÄ±) tekrar nasÄ±l birleÅŸtireceÄŸiz? Ya iki evrende de aynÄ± satÄ±rÄ± deÄŸiÅŸtirdiysek?

ğŸ‘‰ **SÄ±rada:** [2.1 - BirleÅŸtirme SanatÄ±: Merge ve Conflict](./2.1-merge-ve-conflict.md)